#编程规约

###命名风格
 **1. 【强制】** 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元。 反例:name / __name / $Object / name / name$ / Object$1. 

------------


**2. 【强制】** 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中1. 文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式 也要避免采用。 正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3

------------


**3. 【强制】**1. 1. 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：2. DO / BO / DTO / VO / AO 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion

------------


**4.【强制】**1. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。 正例： localValue / getHttpMessage() / inputUserId

------------


** 5. 【强制】**1. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT 反例： MAX_COUNT

------------


** 6. 【强制】**1. 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。

------------


**7. 【强制】**1. 中括号是数组类型的一部分，数组定义如下：String[] args; 反例：使用 String args[]的方式来定义。

------------


**8. 【强制】**1. POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，2 / 33 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异 常。

------------


**9. 【强制】**1. 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考 spring 的框架结构）

------------


**10. 【强制】**1. 杜绝完全不规范的缩写，避免望文不知义。 反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类 随意缩写严重降低了代码的可阅读性。

------------


11. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。 正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = “alibaba”; 反例：接口方法定义：public abstract void f(); 说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默 认实现。

------------


**1.接口和实现类的命名有两套规则：**

**1）【强制】**1. 对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部 的实现类用 Impl 的后缀与接口区别。 正例：CacheServiceImpl 实现 CacheService 接口。

------------


2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是Cable 的形式）。 正例：AbstractTranslator 实现 Translatable。

### (三)代码格式
**1. 【强制】**大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果 是非空代码块则：

1） 左大括号前不换行。

2） 左大括号后换行。

3） 右大括号前换行。

4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。

------------


**2. 【强制】** 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。 反例：if (空格 a == b 空格)

------------


**3. 【强制】**if/for/while/switch/do 等保留字与括号之间都必须加空格。

------------


**4. 【强制】**任何二目、三目运算符的左右两边都需要加一个空格。 说明：运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号等。

------------


**5. 【强制】**1. 缩进采用 4 个空格，禁止使用 tab 字符。 说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时， 请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs

------------


**6. 【强制】**1. 单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则
：
1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。

2） 运算符与下文一起换行。

3） 方法调用的点符号与下文一起换行。

4） 在多个参数超长，在逗号后换行。

5） 在括号前不要换行，

------------


**7. 【强制】**1. 方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例：下例中实参的”a”,后边必须要有一个空格。 method(“a”, “b”, “c”);

------------


**8. 【强制】**1. IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式， 不要使用 windows 格式。

------------


9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 正例： int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer(); 说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的 情况下，是一种累赘的事情。

------------


10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义 之间插入一个空行。相同业务逻辑和语义之间不需要插入空行

------------


### (四)OOP 规约

**1. 【强制**】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。

------------


**2. 【强制】**所有的覆写方法，必须加@Override 注解。 说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编 译报错。

------------


**3. 【强制】**相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程） 正例：public User getUsers(String type, Integer… ids) {…}

------------


**4. 【强制】**1. 外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。

------------


**5. 【强制】**1. 不能使用过时的类或方法。 说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应 该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口， 那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。

------------


**6. 【强制】**1. Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例： “test”.equals(object); 反例： object.equals(“test”); 说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）

------------


**9. 【强制】** 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。 反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具 体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。

------------


**10. 【强制】**序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID 值。 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。

------------


**11. 【强制】**构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。

--------------
**12. 【强制】**1. POJO 类必须写 toString 方法。使用 IDE 的中工具：source> generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排 查问题。

------------


**13. 【推荐】**1. 使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。 说明： String str = “a,b,c,,”; String[] ary = str.split(“,”); //预期大于 3，结果是 3 System.out.println(ary.length);

------------


**14. 【推荐】**1. 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起， 便于阅读。

------------


15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter 方法。 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类 关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个 黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最 后。

------------


**16【强制】**循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。 说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 反例： String str = “start”; for (int i = 0; i < 100; i++) { str = str + “hello”; } 

------------


**17. 【强制】**final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：

1） 不允许被继承的类，如：String 类。

2） 不允许修改引用的域对象，如：POJO 类的域变量。

3） 不允许被重写的方法，如：POJO 类的 setter 方法。

4） 不允许运行过程中重新赋值的局部变量。

5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好 地进行重构。

------------


19. 【推荐】类成员与方法访问控制从严：

1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。

2） 工具类不允许有 public 或 default 构造方法。

3） 类非 static 成员变量并且与子类共享，必须是 protected。

4） 类非 static 成员变量并且仅在本类使用，必须是 private。

5） 类 static 成员变量如果仅在本类使用，必须是 private。

6） 若是 static 成员变量，必须考虑是否为 final。

7） 类成员方法只供类内部调用，必须是 private。

8） 类成员方法只对继承类公开，那么限制为 protected。 说明：任何类、方法、参数、变量，严控访问范围。 

## 二、异常日志

### (一)异常处理

**1. 【强制】**1. Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该 通过 catch 来处理，比如：IndexOutOfBoundsException，NullPointerException 等等。 说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch NumberFormatException 来实现。 正例：if (obj != null) {…} 反例：try { obj.method() } catch (NullPointerException e) {…}

------------


**2. 【强制1. 】**异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。

------------


**3. 【强制】**1. 对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳 定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分 异常类型，再做对应的异常处理。

------------


**4. 【强制】**1. 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。

------------


**5. 【强制】**1. 有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。

------------


**6. 【强制】**1. finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 说明：如果 JDK7 及以上，可以使用 try-with-resources 方式。

------------


**7. 【强制】**1. 不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不 会再执行 try 块中的 return 语句。

------------


**8. 【强制】**1. 捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。 

------------


**9. 【强制】**方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分 说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。 说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用 者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。

------------


**10. 【强制】**防止 NPE，是程序员的基本修养，注意 NPE 产生的场景： 1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。

------------


**11. 【强制】**定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()， 更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义 过的自定义异常，如：DAOException / ServiceException 等。

------------


12. 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须 使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封 装 isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于 RPC 方法返回方式使用 Result 方式的理由：

1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。

2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用 端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输 的性能损耗也是问题。

------------


13. 【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副 本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。 正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：

------------


### 五、安全规约

**1. 【强制】**隶属于用户个人的页面或者功能必须进行权限控制校验。 说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看人的私信 内容、修改他人的订单。

------------


**2. 【强制】**用户敏感数据禁止直接展示，必须对展示数据进行脱敏。 说明：查看个人手机号码会显示成:158\*\*\*9119，隐藏中间 4 位，防止隐私泄露。

------------


**3. 【强制】**用户输入的 sqlite参数严格使用参数绑定或者 METADATA 字段值限定，防止 sqlite 注入， 禁止字符串拼接 sqlite访问数据库。

------------


**4. 【强制】**用户请求传入的任何参数必须做有效性验证。 说明：忽略参数校验可能导致： ? page size 过大导致内存溢出 ? 恶意 order by 导致数据库慢查询 ? 任意重定向 ? sqlite 注入 ? 反序列化注入 ? 正则输入源串拒绝服务 ReDoS 说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。

------------


**5.【强制】**在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其 它用户，并造成短信平台资源浪费。

------------


6. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过 滤等风控策略。










































































































































































   